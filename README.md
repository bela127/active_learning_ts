# active learning test suit

Active learning test suite is a test suite for active learning algorithms.
Its main purpose is the evaluation of active learning algorithms.
For a given surrogate model, and a given knowledge discovery task, this test suite is designed to evaluate
both the surrogate model and the test.

## used srces

https://github.com/Project-Platypus/PRIM
https://github.com/quaquel/EMAworkbench
https://github.com/scikit-activeml/scikit-activeml


https://pubsonline.informs.org/doi/pdf/10.1287/opre.41.3.435

https://www.sciencedirect.com/science/article/pii/S0925231214008145

## Defining a test
In order to define a test, a blueprint file must be created.
This must contain the following variables ([Blueprint](./active_learning_ts/experiments/blueprint.py)):

### Repeat

Currently, does nothing

### Learning Steps

A learning step consists of a batch of queries that are queried from the data source.
A learning step is subdivided into four section: 'Query Selection', 'Data Retrievement', 'Model Training', 
'Knowledge Discovery' and 'Evaluation', in that order.

This specifies how many learning steps should be taken

### Data source

The data source stores/generates data, in order to answer batches queries.

### Selection Criteria

The Selection Criteria is responsible for evaluating how beneficial a query would be, while cosidering:
Cost, The surrogate Model, The knowledge Discovery Task

### Retrievement Strategy

The retrievement strategy takes a query, generated by  the Query optimizer, and generates a batch of valid queries
that will be queried from the data source. 
The size of a batch depends on the retrievement strategy

This would for example allow a discrete Data source to be accessed as if it were continuous.
The retrievement strategy is therefore also responsible for informing the Query Optimizer, about which queries are
possible for the query optimizer to make.

As an example: one could define a data source that is discrete, and chose a Retrievement Strategy that converts that 
allows this data source to be accessed as if it were continuous.
The retrievement Strategy, would inform the query optimizer, that the data source is continuous.

### Query Optimizer

The job of the query optimizer is to consider previously queried points, and the pool of all possible queries to 
generate large batches of queries.
It will then evaluate these queries using the selection criteria, and only the best of them is queried from the data 
source.

### Interpolation Strategy

The retrievement strategy is asked one query, and returns a batch of queries.
These batches are then answered.
At this point, we have data of the form (Original query, [ many queries ], [many results]).
The Interpolation Strategy is therefore responsible for returning data of the for ([many queries], [many results]).
There are many ways with which this could be done, solutions range from ignoring the original query, to interpolating
the results (in which case the output lists would be of length one)

### Surrogate Model

The surrogate Model's main purpose is to simulate the given Data source.
Depending on the knowledge discovery task, the surrogate Model might not aim to perfectly simulate the data Source,
so it is imperative that this is chosen to fit the task.

### Training Strategy

The Training Strategy is responsible for analysing the Surrogate Model, the queries that have been asked and the knowledge
discovery task, in order to give feedback to the Surrogate Model on how it should train.

### Evaluation Metrics

There are many metrics that one might want to evaluate.
The evaluation metrics are given access to all data in the current experiment (even other evaluation metrics).
Examples of simple evaluation metrics, are round timers, and counters for the number of points queried.
Some evaluation metrics can take lots of time, signals are therefore used to notify evaluation metrics about what work 
is currently being done.

### Instance level Objective

not really implemented. Insert ConstantInstanceObjective()  as placeholder

### Instance Cost

not really implemented. Insert ConstantInstanceCost() as placeholder

### Augmentation Pipeline

not really implemented. Insert NoAugmentation() as placeholder

# Installation



